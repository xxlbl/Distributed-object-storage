## 架构

![image-20230208134017484](/Users/ljf/Library/Application Support/typora-user-images/image-20230208134017484.png)

数据服务：数据存储的节点

接口服务：处理客户端的请求

消息队列

客户端——接口服务节点——数据服务exchange——数据服务
​										｜
​										  —— restful接口——数据服务

数据服务——接口服务exchange——接口服务（通知数据服务自身存在通知给所有接口服务）

数据服务——本地磁盘—存取

-----

接口服务和数据服务之间的接口有两种，第一种接口实现对象的存取。和上一个版本一样，对象的存取使用 REST 接口。也就是说数据服务本身也提供 REST 接口， 此时，接口服务节点作为 HTTP 客户端向数据服务请求对象。

第二种接口通过 RabbitMQ 消息队列进行通信。关于 RabbitMQ 消息队列的详细介绍请参见其官网。在我们的架构中对 RabbiIMQ 的使用分为两种模式，一种模式是向某个 exchange 进行一对多的消息群发，另一种模式则是向某个消息队列进行一对一的消息单发。

之所以必须使用 REST 和消息队列这两种不同类型的接口是为了满足不同的需求：对象存取的特点是数据量有可能很大，不适合将一个巨大的对象通过消息队列传输。而 REST 接口虽然能够处理大数据量传输，但是对于群发却显得力不从心。

## 心跳

## 查询定位

## 不足

经过解除耦合可以向集群添加任意的新的接口服务节点和数据服务节点。

1. 多次put同一个对象会发现所有数据节点都有一个副本，需要**数据去重**。另外<u>不同用户上传的同样的数据可能名称不同</u>，需要**共享同一份数据存储**。

2. 另一个问题则是数据的不一致。假设我们多次 PUT 同一个对象，且内容不同， 这个对象的不同版本会被随机保存在不同的数据服务节点上。而当我们 GET 它时就会随机取得不同版本的对象，这不仅破坏了对象数据的一致性，也破坏了 GET 方法的幂等性。

   所调**版本控制**，指的就是用户上传的某个对象的所有版本都被保存起来。比如说，当用户第一次上传一个对象时，它的初始版本为1；当用户使用 PUT 方法改变了该对象的内容，那么新对象的版本为 2，依次递增。**新的版本会覆盖旧的版本，但是旧版本的对象不会被删除**。在下载对象时，用户可以指定 GET 对象的任意一个版本。为了实现版本控制，我们需要一个数据库来记录系统中所有对象的所有版本。这个数据库就是我们的**元数据服务**