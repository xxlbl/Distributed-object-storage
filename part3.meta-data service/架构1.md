## 架构

![image-20230208162633978](/Users/ljf/Library/Application Support/typora-user-images/image-20230208162633978.png)

[redis，MongoDB，ES的对比_繁婲卍似錦的博客-CSDN博客_mongodb es](https://blog.csdn.net/zhanglongfei_test/article/details/121476596)

新增元数据数据库

```go
{
Name    string
Version int
Size    int64
Hash    string
}
```

对象的唯一标识：哈希值

对象的散列值是一种非常特殊的元数据，因为对象存储通常**将对象的散列值作为其全局唯一的标识符**。在此前，数据服务节点上的对象都是用名字来引用的，如果两个对象名字不同，那么我们无法知道它们的内容是否相同。这让我们无法实现针对不同对象的去重。现在，以对象的散列值作为标识符，我们就<u>可以将接口服务层访问的对象和数据服务存取的对象数据解耦合</u>。**客户端和接口服务**通过对象的**名字**来引用一个对象，而实际则是**通过其散列值**来引用**存储在数据节点上的对象数据**，只要散列值相同则可以认为对象的数据相同，这样就可以实现名字不同但数据相同的对象之间的去重。

实现使用的散列函数是 SHA-256，该函数使用 64 轮的数学运算，产生一个长度为256 位的二进制数字作为散列值。

ES 使用的也是 **REST 接口**，我们的接口服务节点作为客户端通过 HTTP 访问 ES 的索引 （index)。ES 的**索引**就相当于一个**数据库**，而**类型**（ype）则相当于数据库里的一张**表**。我们会创建一个名为 **metadata 的索引**，其中有一个名为 **objects** 的**类型**。

## 总结和不足

有了**元数据服务**，我们可以在不实际删除数据的情况下实现对象的**删除**功能；我们可以实现对象的**版本控制**；我们还确保了对象数据的一致性和 GET 方法的幂等性。这些都是因为元数据服务可以保存对象的元数据。

接口服务会要求**客户端提供对象的散列值**作为其**全局唯一的标识符**，也就是**数据服务存储的对象名**，但是**我们没有对这个散列值进行校验**，<u>用户提供的对象散列值和数据有可能是不一致的</u>，产生不一致的原因有很多，需要把**数据校验**加入我们的服务。